{"version":3,"sources":["E:/workspaces/tab-group/docs/apis/TabHeader.mdx","E:/workspaces/tab-group/src/components/TabHeaderContext.ts","E:/workspaces/tab-group/src/components/TabListContext.ts","E:/workspaces/tab-group/src/components/commons/useTabList.ts","E:/workspaces/tab-group/src/helpers/usePreventTransitionWhenMount.ts","E:/workspaces/tab-group/src/components/tab-header/TabHeaderWrapper.tsx","E:/workspaces/tab-group/src/components/InkBar.tsx","E:/workspaces/tab-group/src/components/tab-header/InnerTabHeader.tsx","E:/workspaces/tab-group/src/components/tab-header/TabHeader.tsx","E:/workspaces/tab-group/src/helpers/useRefValue.ts"],"names":["layoutProps","MDXLayout","MDXContent","components","props","mdxType","of","TabHeader","isMDXComponent","TabHeaderContext","React","createContext","TabListContext","useTabList","selectedIndex","useState","renderCount","setRenderCount","isRenderredRef","useRef","tabsRef","sortedTabsRef","tabsPropsRef","current","useEffect","register","useCallback","tabId","sortedTabs","currentIdx","indexOf","state","push","idx","length","unregister","tabs","tabIdx","splice","getTabs","getTabProps","useMemo","usePreventTransitionWhenMount","elementRef","element","transition","style","rafId","requestAnimationFrame","cancelAnimationFrame","borderCss","css","TabHeaderWrapper","styled","div","theme","palette","text","primary","borderless","topCss","InkBar","attrs","className","top","transitions","create","InnerTabHeader","children","extraContent","tabListRef","inkBarRef","inkBar","tabList","activeTab","querySelector","getBoundingClientRect","width","left","containerLeft","transform","role","ref","data-testid","dense","onSelect","onSelectRef","useRefValue","context","tabIndex","event","Provider","value"],"mappings":"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","file":"static/js/docs-apis-tab-header.fdd9976e.js","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { Playground, Props } from 'docz';\nimport TabHeader from '../../src/components/tab-header/TabHeader';\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"tabheader\"\n    }}>{`TabHeader`}</h1>\n    <Props of={TabHeader} mdxType=\"Props\" />\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;","import React from 'react';\n\ninterface TabHeaderContextState {\n  /**\n   * 是否是密集模式\n   */\n  dense?: boolean;\n\n  /**\n   * 变更当前选项卡\n   */\n  onSelect: (\n    tabIndex: number,\n    event: React.MouseEvent | React.KeyboardEvent,\n  ) => void;\n}\n\n/**\n * 标签头部上下文\n */\nconst TabHeaderContext = React.createContext<TabHeaderContextState | null>(\n  null,\n);\n\nexport default TabHeaderContext;\n","import React from 'react';\n\nexport interface TabProps {\n  disabled?: boolean;\n}\n\nexport interface TabListContextState {\n  /**\n   * 注册标签页\n   */\n  register: (tabId: string, props: TabProps) => number;\n  /**\n   * 取消注册标签页\n   */\n  unregister: (tabId: string) => void;\n  /**\n   * 当前选中标签页的索引。索引从 0 开始。\n   */\n  selectedIndex: number;\n  /**\n   * 获取所有标签页的id\n   */\n  getTabs(): string[];\n  getTabProps(tabId: string): TabProps;\n}\n\n/**\n * 标签列表上下文\n */\nconst TabListContext = React.createContext<TabListContextState | null>(null);\n\nexport default TabListContext;\n","import { useEffect, useState, useRef, useCallback, useMemo } from 'react';\nimport { TabProps } from '../TabListContext';\n\n/**\n * 标签页列表状态管理\n */\nfunction useTabList(selectedIndex: number) {\n  const [renderCount, setRenderCount] = useState(1); // 内部 tab 发生变化引起重绘的次数\n  const isRenderredRef = useRef(false); // 是否已经同步渲染过\n  const tabsRef = useRef<string[]>([]); // 所有包含标签页（无序的）\n  const sortedTabsRef = useRef<string[]>([]); // 包含的有序的标签页\n  const tabsPropsRef = useRef<{ [name: string]: TabProps }>({});\n  sortedTabsRef.current = []; // TODO: current mode 可能会有缺陷，参见： https://github.com/facebook/react/issues/14099\n  isRenderredRef.current = false; // TODO: current mode 可能会有缺陷，参见： https://github.com/facebook/react/issues/14099\n\n  useEffect(() => {\n    isRenderredRef.current = true;\n  });\n\n  /**\n   * 注册标签页\n   */\n  const register = useCallback((tabId: string, props: TabProps) => {\n    const sortedTabs = sortedTabsRef.current;\n    const currentIdx = sortedTabs.indexOf(tabId);\n    if (isRenderredRef.current && currentIdx === -1) {\n      setRenderCount((state) => state + 1);\n      return -1;\n    }\n\n    const isAdded = tabsRef.current.indexOf(tabId) !== -1;\n\n    if (!isAdded) {\n      tabsRef.current.push(tabId);\n      tabsPropsRef.current[tabId] = props;\n    }\n\n    if (currentIdx !== -1) {\n      return currentIdx;\n    }\n\n    const idx = sortedTabs.length;\n    sortedTabs.push(tabId);\n\n    return idx;\n  }, []);\n\n  /**\n   * 取消注册标签页\n   */\n  const unregister = useCallback((tabId: string) => {\n    const sortedTabs = sortedTabsRef.current;\n    const tabs = tabsRef.current;\n    const idx = sortedTabs.indexOf(tabId);\n\n    const tabIdx = tabs.indexOf(tabId);\n    if (tabIdx !== -1) {\n      tabs.splice(tabIdx, 1);\n      delete tabsPropsRef.current[tabId];\n    }\n\n    if (idx !== -1) {\n      sortedTabs.splice(idx, 1);\n\n      setRenderCount((state) => state + 1);\n    }\n  }, []);\n\n  /**\n   * 获取所有标签id\n   */\n  const getTabs = useCallback(() => {\n    return sortedTabsRef.current;\n  }, []);\n\n  /**\n   * 获取指定id的属性\n   */\n  const getTabProps = useCallback((tabId: string) => {\n    return tabsPropsRef.current[tabId];\n  }, []);\n\n  return useMemo(\n    () => ({\n      register,\n      unregister,\n      selectedIndex,\n      renderCount,\n      getTabs,\n      getTabProps,\n    }),\n    [getTabProps, getTabs, register, renderCount, selectedIndex, unregister],\n  );\n}\n\nexport default useTabList;\n","import { useEffect } from 'react';\n\n/**\n * 在组件初次渲染时阻止 transition 动画\n */\nfunction usePreventTransitionWhenMount<T extends HTMLElement>(\n  elementRef: React.RefObject<T>,\n) {\n  useEffect(() => {\n    const element = elementRef.current;\n    if (element) {\n      const { transition } = element.style;\n      element.style.transition = 'none';\n      const rafId = requestAnimationFrame(() => {\n        element.style.transition = transition;\n      });\n\n      return () => cancelAnimationFrame(rafId);\n    }\n    return undefined;\n  }, [elementRef]);\n}\n\nexport default usePreventTransitionWhenMount;\n","import styled, { css } from 'styled-components';\n\ninterface Props {\n  borderless?: boolean;\n}\n\nconst borderCss = css`\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n`;\n\nconst TabHeaderWrapper = styled.div<Props>`\n  display: flex;\n  overflow: hidden;\n  flex-shrink: 0;\n  font-size: 1rem;\n  color: ${(props) => props.theme.palette.text.primary};\n\n  ${(props) => !props.borderless && borderCss}\n\n  .sinoui-tab-label-container {\n    display: flex;\n    flex-grow: 1;\n    overflow: hidden;\n    z-index: 1;\n  }\n\n  .sinoui-tab-list {\n    flex-grow: 1;\n    position: relative;\n    transition: transform 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n  }\n\n  .sinoui-tab-labels {\n    display: flex;\n    position: relative;\n  }\n\n  .sinoui-tab-header-extra-content {\n    line-height: 48px;\n  }\n`;\n\nexport default TabHeaderWrapper;\n","import styled, { css } from 'styled-components';\n\nconst topCss = css`\n  top: 0;\n`;\n\ninterface Props {\n  top?: boolean;\n}\n\n/**\n * 选择指示器\n */\nconst InkBar = styled.div.attrs({\n  className: 'sinoui-ink-bar',\n})<Props>`\n  position: absolute;\n  bottom: 0;\n  ${(props) => props.top && topCss};\n  left: 0;\n  transition: ${(props) =>\n    props.theme.transitions.create(['transform', 'width'])};\n  height: 2px;\n  background-color: ${(props) => props.theme.palette.primary[500]};\n`;\n\nexport default InkBar;\n","import React, { useEffect, useRef } from 'react';\nimport usePreventTransitionWhenMount from '../../helpers/usePreventTransitionWhenMount';\nimport TabHeaderWrapper from './TabHeaderWrapper';\nimport InkBar from '../InkBar';\n\ninterface Props {\n  children: React.ReactNode;\n  /**\n   * 在标签右侧添加附件内容。\n   */\n  extraContent?: React.ReactNode;\n  /**\n   * 设置不显示底部线条。默认为 `false`。\n   */\n  borderless?: boolean;\n}\n\nfunction InnerTabHeader({ children, extraContent, borderless }: Props) {\n  const tabListRef = useRef<HTMLDivElement>(null);\n  const inkBarRef = useRef<HTMLDivElement>(null);\n\n  usePreventTransitionWhenMount(inkBarRef);\n\n  useEffect(() => {\n    const inkBar = inkBarRef.current;\n    const tabList = tabListRef.current;\n    if (inkBar && tabList) {\n      const activeTab = tabList.querySelector('.sinoui-tab-label-active');\n      if (activeTab) {\n        const { width, left } = activeTab.getBoundingClientRect();\n        const { left: containerLeft } = tabList.getBoundingClientRect();\n        inkBar.style.width = `${width}px`;\n        inkBar.style.transform = `translate3d(${left -\n          containerLeft}px, 0px, 0px)`;\n      }\n    }\n  });\n\n  return (\n    <TabHeaderWrapper\n      className=\"sinoui-tab-header\"\n      role=\"tablist\"\n      borderless={borderless}\n    >\n      <div className=\"sinoui-tab-label-container\">\n        <div className=\"sinoui-tab-list\" ref={tabListRef}>\n          <div className=\"sinoui-tab-labels\">{children}</div>\n          <InkBar ref={inkBarRef} data-testid=\"inkbar\" />\n        </div>\n        {extraContent ? (\n          <div className=\"sinoui-tab-header-extra-content\">{extraContent}</div>\n        ) : null}\n      </div>\n    </TabHeaderWrapper>\n  );\n}\n\nexport default InnerTabHeader;\n","import React, { useMemo } from 'react';\nimport TabHeaderContext from '../TabHeaderContext';\nimport useRefValue from '../../helpers/useRefValue';\nimport InnerTabHeader from './InnerTabHeader';\nimport TabListContext from '../TabListContext';\nimport useTabList from '../commons/useTabList';\n\ninterface Props {\n  children?: React.ReactNode;\n  /**\n   * 指定在密集模式下使用。\n   */\n  dense?: boolean;\n  /**\n   * 设置当前选中的标签页。这是一个从 `0` 开始的索引，第一个标签页的索引为 `0`，第二个标签页的索引为 `1`，……\n   */\n  selectedIndex: number;\n  /**\n   * 每次标签页切换时调用的事件处理器。这个函数的 `index` 参数是新的选中标签页索引，`lastIndex` 参数是变更之前选中的标签页索引，`event` 参数是引起页签切换的事件，可能是 `keydown` 或者 `click` 事件。如果 `index` 和 `lastIndex` 相同时，表示用户在当前选中的标签页上点击。\n   */\n  onSelect?: (\n    index: number,\n    lastIndex: number,\n    event: React.MouseEvent | React.KeyboardEvent,\n  ) => boolean | undefined | void;\n  /**\n   * 在标签右侧添加附件内容。\n   */\n  extraContent?: React.ReactNode;\n  /**\n   * 设置不显示底部线条。默认为 `false`。\n   */\n  borderless?: boolean;\n}\n\n/**\n * 选项卡头部组件\n *\n */\nfunction TabHeader({\n  children,\n  dense,\n  selectedIndex = 0,\n  onSelect,\n  extraContent,\n  borderless,\n}: Props) {\n  const tabList = useTabList(selectedIndex);\n\n  const onSelectRef = useRefValue(onSelect);\n\n  const context = useMemo(\n    () => ({\n      dense,\n      onSelect: (\n        tabIndex: number,\n        event: React.MouseEvent | React.KeyboardEvent,\n      ) => {\n        if (onSelectRef.current) {\n          onSelectRef.current(tabIndex, selectedIndex, event);\n        }\n      },\n    }),\n    [dense, onSelectRef, selectedIndex],\n  );\n\n  return (\n    <TabListContext.Provider value={tabList}>\n      <TabHeaderContext.Provider value={context}>\n        <InnerTabHeader extraContent={extraContent} borderless={borderless}>\n          {children}\n        </InnerTabHeader>\n      </TabHeaderContext.Provider>\n    </TabListContext.Provider>\n  );\n}\n\nexport default TabHeader;\n","import { useRef } from 'react';\n\n/**\n * 使用同步的“变量”\n */\nfunction useRefValue<T>(value: T) {\n  const ref = useRef(value);\n\n  ref.current = value;\n\n  return ref;\n}\n\nexport default useRefValue;\n"],"sourceRoot":""}